# 문자열 게임 2 - 20437 

[문제 링크](https://www.acmicpc.net/problem/20437) 

### 성능 요약

메모리: 21204 KB, 시간: 292 ms

### 분류

슬라이딩 윈도우, 문자열

### 제출 일자

2025년 3월 18일 18:17:05

### 문제 설명

<p>작년에 이어 새로운 문자열 게임이 있다. 게임의 진행 방식은 아래와 같다.</p>

<ol>
	<li>알파벳 소문자로 이루어진 문자열 W가 주어진다.</li>
	<li>양의 정수 K가 주어진다.</li>
	<li>어떤 문자를 정확히 K개를 포함하는 가장 짧은 연속 문자열의 길이를 구한다.</li>
	<li>어떤 문자를 정확히 K개를 포함하고, 문자열의 첫 번째와 마지막 글자가 해당 문자로 같은 가장 긴 연속 문자열의 길이를 구한다.</li>
</ol>

<p>위와 같은 방식으로 게임을 T회 진행한다.</p>

### 입력 

 <p>문자열 게임의 수 T가 주어진다. (1 ≤ T ≤ 100)</p>

<p>다음 줄부터 2개의 줄 동안 문자열 W와 정수 K가 주어진다. (1 ≤ K ≤ |W| ≤ 10,000) </p>

### 출력 

 <p>T개의 줄 동안 문자열 게임의 3번과 4번에서 구한 연속 문자열의 길이를 공백을 사이에 두고 출력한다.</p>

<p>만약 만족하는 연속 문자열이 없을 시 -1을 출력한다.</p>

### 느낀점

- 그냥 감대로 풀었는데, 슬라이딩 윈도우 알고리즘을 통해 푸는 문제같아서 잠시 방식을 찾아봤다.
    - 고정된 사이즈의 윈도우를 한칸씩 이동시키면서 추가된 요소를 기록하고, 배출된 요소를 기록하여 현재 윈도우 안에 있는 요소들의 상태를 판단한다.

### 설계 : 20분

- 각 소문자 알파벳에 대한 첫 발견지점과 개수를 기록할 int[] start, int[] cnt 배열을 생성한다.
- `알파벳 문자 - 97` 을 하면 0~25까지의 인덱스를 사용할 수 있다.
- 문자열의 처음부터 끝까지 문자를 순회한다.
    - 문자열을 순회하면서 문자(c)에 대해 cnt[c]가 아직 0이라면 start[c]를 해당 위치로 설정한다.
    - cnt[c]를 1증가시킨다.
    - cnt[c] == k 이면, 시작지점부터 현재 위치까지의 길이를 답에 갱신하고, 시작지점을 해당 알파벳이 다음으로 나타난 위치로 이동한다.
    - cnt[c]를 1감소시켜서 다시 해당 알파벳을 발견할 경우 길이를 갱신할 수 있도록 한다.