package prgs_유사칸토어비트열;

// 1 -> 11011
// 0 -> 00000

// 1번째 유사칸토어비트열: 11011
// 		[1, 5] => 4
//		중간 부분: [3,3]은 0
// 2번째 유사칸토어비트열: 11011 / 11011 / 00000 / 11011 / 11011
// 		[1, 25] => 4 * 4 = 16
// 		중간 부분: [11, 15]은 전부 0
// 3번째 유사칸토어비트열: 1101111011000001101111011 / 1101111011000001101111011 / 0000000000000000000000000 / 1101111011000001101111011 / 1101111011000001101111011
// 		[1, 125] => 16 * 4 = 64
// 		중간 부분: [51, 75]은 전부 0

import java.util.*;

class Solution {
	public int solution(int n, long l, long r) {
		return func(n, l, r);
	}
	
	static int func(int n, long l, long r) {
		
		// 1의 개수를 반환할 num 변수 선언
		int sum = 0;
		
		// n이 1인 경우(탈출 조건)
		// 1번째 유사칸토어비트열: 11011
		if (n == 1) {
			for (long i = l; i <= r; i++) {
				// 중간 부분(i == 3)을 제외하고, [l,r] 사이의 1을 더해 계산
				if (i != 3) {
					sum++;
				}
			}
			return sum;
		}

		
		// k는 n번째 유사칸토어비트열을 5로 나눴을 때의 값
		// ex) n=3일 때 전체 유사칸토어비트열은 125이고, k는 25가 된다.
		// k값을 활용해서 l, r의 위치에 따라 더해야 할 1의 개수를 생각해보자.
		long k = (long) Math.pow(5, n - 1);

		// | 1 | 2 | 3 | 4 | 5 |
		// 유사칸토어비트열을 위와 같이 5개의 파티션으로 나눠보자.
		// 이 중 l이 속하는 파티션을 st, r이 속하는 파티션을 ed라 정의하자.
		long st = (l - 1) / k + 1;
		long ed = (r - 1) / k + 1;

		
		// l, r이 속한 파티션을 순회하면서 생기는 각 경우의 수를 처리하자.
		for (long i = st; i <= ed; i++) {

			// 3번째 파티션은 전부 0이므로 PASS
			if (i == 3) {
				continue;
			}
			
			// 두 가지 경우가 발생 가능하다.
			// 1. l, r이 같은 파티션에 속하는 경우
			if (st == ed) {		
				sum += func(n - 1, (l - 1) % k + 1, (r - 1) % k + 1);
			}
			
			// 2. l, r이 다른 파티션에 속하는 경우
			else {				
				if (i == st) {
					// l이 속한 파티션(st)에서는 l의 위치에 맞게 func을 재호출해야 한다.
					// n-1번째 유사칸토어비트열 속의 l을 나머지 연산을 통해 새로운 l을 설정, r은 n-1번째 유사칸토어비트열의 길이로 설정
					// ex) n=2, l=4, r=17일 때, func(1, 4, 5)를 호출
					sum += func(n - 1, (l - 1) % k + 1, k);
				} else if (i == ed) {
					// 위와 같은 원리로, r이 속한 파티션(ed)에서도 r의 위치에 맞게 func을 재호출해야 한다.
					// ex) n=2, l=4, r=17일 때, func(1, 1, 2)를 호출
					sum += func(n - 1, 1, (r - 1) % k + 1);
				} else {
					// 나머지 파티션에 대해서는 n-1번째 유사 칸토어 비트열의 전체 1 개수의 합인 4^(n-1)을 더해주면 된다.(3번째 파티션은 이미 위에서 고려)
					sum += Math.pow(4, n - 1);
				}
			}

		}

		return sum;
	}

}
